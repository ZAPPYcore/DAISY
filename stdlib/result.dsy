module result

enum Result<T, E>:
  case Ok: T
  case Err: E

fn ok<T, E>(value: T) -> Result<T, E>:
  return Result.Ok(value)

fn err<T, E>(value: E) -> Result<T, E>:
  return Result.Err(value)

fn is_ok<T, E>(value: Result<T, E>) -> bool:
  match value:
    case Result.Ok(_):
      return true
    else:
      return false
  return false

fn is_err<T, E>(value: Result<T, E>) -> bool:
  match value:
    case Result.Err(_):
      return true
    else:
      return false
  return false

fn unwrap_or<T, E>(value: Result<T, E>, fallback: T) -> T:
  match value:
    case Result.Ok(v):
      return v
    else:
      return fallback
  return fallback

fn unwrap_or_else<T, E>(value: Result<T, E>, fallback: T) -> T:
  match value:
    case Result.Ok(v):
      return v
    else:
      return fallback
  return fallback

fn map<T, E, U>(value: Result<T, E>, mapped: U) -> Result<U, E>:
  match value:
    case Result.Ok(_):
      return Result.Ok(mapped)
    case Result.Err(e):
      return Result.Err(e)

fn and_then<T, E>(value: Result<T, E>, next: Result<T, E>) -> Result<T, E>:
  match value:
    case Result.Ok(_):
      return next
    case Result.Err(e):
      return Result.Err(e)
  return next

fn flatten<T, E>(value: Result<Result<T, E>, E>) -> Result<T, E>:
  match value:
    case Result.Ok(inner):
      return inner
    case Result.Err(e):
      return Result.Err(e)

fn expect<T, E>(value: Result<T, E>, message: string) -> T:
  match value:
    case Result.Ok(v):
      return v
    case Result.Err(_):
      return panic(message)


