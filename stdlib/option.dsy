module option

enum Option<T>:
  case Some: T
  case None

fn some<T>(value: T) -> Option<T>:
  return Option.Some(value)

fn none<T>() -> Option<T>:
  return Option.None()

fn is_some<T>(value: Option<T>) -> bool:
  match value:
    case Option.Some(_):
      return true
    else:
      return false
  return false

fn is_none<T>(value: Option<T>) -> bool:
  match value:
    case Option.None():
      return true
    else:
      return false
  return false

fn unwrap_or<T>(value: Option<T>, fallback: T) -> T:
  match value:
    case Option.Some(v):
      return v
    else:
      return fallback
  return fallback

fn unwrap_or_else<T>(value: Option<T>, fallback: T) -> T:
  match value:
    case Option.Some(v):
      return v
    else:
      return fallback
  return fallback

fn map<T, U>(value: Option<T>, mapped: U) -> Option<U>:
  match value:
    case Option.Some(_):
      return Option.Some(mapped)
    else:
      return Option.None()

fn and_then<T>(value: Option<T>, next: Option<T>) -> Option<T>:
  match value:
    case Option.Some(_):
      return next
    else:
      return Option.None()
  return next

fn flatten<T>(value: Option<Option<T>>) -> Option<T>:
  match value:
    case Option.Some(inner):
      return inner
    case Option.None():
      return Option.None()

fn expect<T>(value: Option<T>, message: string) -> T:
  match value:
    case Option.Some(v):
      return v
    case Option.None():
      return panic(message)


